"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@capacitor";
exports.ids = ["vendor-chunks/@capacitor"];
exports.modules = {

/***/ "(ssr)/./node_modules/@capacitor/core/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@capacitor/core/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Capacitor: () => (/* binding */ Capacitor),\n/* harmony export */   CapacitorCookies: () => (/* binding */ CapacitorCookies),\n/* harmony export */   CapacitorException: () => (/* binding */ CapacitorException),\n/* harmony export */   CapacitorHttp: () => (/* binding */ CapacitorHttp),\n/* harmony export */   ExceptionCode: () => (/* binding */ ExceptionCode),\n/* harmony export */   SystemBarType: () => (/* binding */ SystemBarType),\n/* harmony export */   SystemBars: () => (/* binding */ SystemBars),\n/* harmony export */   SystemBarsStyle: () => (/* binding */ SystemBarsStyle),\n/* harmony export */   WebPlugin: () => (/* binding */ WebPlugin),\n/* harmony export */   WebView: () => (/* binding */ WebView),\n/* harmony export */   buildRequestInit: () => (/* binding */ buildRequestInit),\n/* harmony export */   registerPlugin: () => (/* binding */ registerPlugin)\n/* harmony export */ });\n/*! Capacitor: https://capacitorjs.com/ - MIT License */\nvar ExceptionCode;\n(function (ExceptionCode) {\n    /**\n     * API is not implemented.\n     *\n     * This usually means the API can't be used because it is not implemented for\n     * the current platform.\n     */\n    ExceptionCode[\"Unimplemented\"] = \"UNIMPLEMENTED\";\n    /**\n     * API is not available.\n     *\n     * This means the API can't be used right now because:\n     *   - it is currently missing a prerequisite, such as network connectivity\n     *   - it requires a particular platform or browser version\n     */\n    ExceptionCode[\"Unavailable\"] = \"UNAVAILABLE\";\n})(ExceptionCode || (ExceptionCode = {}));\nclass CapacitorException extends Error {\n    constructor(message, code, data) {\n        super(message);\n        this.message = message;\n        this.code = code;\n        this.data = data;\n    }\n}\nconst getPlatformId = (win) => {\n    var _a, _b;\n    if (win === null || win === void 0 ? void 0 : win.androidBridge) {\n        return 'android';\n    }\n    else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {\n        return 'ios';\n    }\n    else {\n        return 'web';\n    }\n};\n\nconst createCapacitor = (win) => {\n    const capCustomPlatform = win.CapacitorCustomPlatform || null;\n    const cap = win.Capacitor || {};\n    const Plugins = (cap.Plugins = cap.Plugins || {});\n    const getPlatform = () => {\n        return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);\n    };\n    const isNativePlatform = () => getPlatform() !== 'web';\n    const isPluginAvailable = (pluginName) => {\n        const plugin = registeredPlugins.get(pluginName);\n        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {\n            // JS implementation available for the current platform.\n            return true;\n        }\n        if (getPluginHeader(pluginName)) {\n            // Native implementation available.\n            return true;\n        }\n        return false;\n    };\n    const getPluginHeader = (pluginName) => { var _a; return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find((h) => h.name === pluginName); };\n    const handleError = (err) => win.console.error(err);\n    const registeredPlugins = new Map();\n    const registerPlugin = (pluginName, jsImplementations = {}) => {\n        const registeredPlugin = registeredPlugins.get(pluginName);\n        if (registeredPlugin) {\n            console.warn(`Capacitor plugin \"${pluginName}\" already registered. Cannot register plugins twice.`);\n            return registeredPlugin.proxy;\n        }\n        const platform = getPlatform();\n        const pluginHeader = getPluginHeader(pluginName);\n        let jsImplementation;\n        const loadPluginImplementation = async () => {\n            if (!jsImplementation && platform in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations[platform] === 'function'\n                        ? (jsImplementation = await jsImplementations[platform]())\n                        : (jsImplementation = jsImplementations[platform]);\n            }\n            else if (capCustomPlatform !== null && !jsImplementation && 'web' in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations['web'] === 'function'\n                        ? (jsImplementation = await jsImplementations['web']())\n                        : (jsImplementation = jsImplementations['web']);\n            }\n            return jsImplementation;\n        };\n        const createPluginMethod = (impl, prop) => {\n            var _a, _b;\n            if (pluginHeader) {\n                const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);\n                if (methodHeader) {\n                    if (methodHeader.rtype === 'promise') {\n                        return (options) => cap.nativePromise(pluginName, prop.toString(), options);\n                    }\n                    else {\n                        return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);\n                    }\n                }\n                else if (impl) {\n                    return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);\n                }\n            }\n            else if (impl) {\n                return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);\n            }\n            else {\n                throw new CapacitorException(`\"${pluginName}\" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n            }\n        };\n        const createPluginMethodWrapper = (prop) => {\n            let remove;\n            const wrapper = (...args) => {\n                const p = loadPluginImplementation().then((impl) => {\n                    const fn = createPluginMethod(impl, prop);\n                    if (fn) {\n                        const p = fn(...args);\n                        remove = p === null || p === void 0 ? void 0 : p.remove;\n                        return p;\n                    }\n                    else {\n                        throw new CapacitorException(`\"${pluginName}.${prop}()\" is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n                    }\n                });\n                if (prop === 'addListener') {\n                    p.remove = async () => remove();\n                }\n                return p;\n            };\n            // Some flair âœ¨\n            wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;\n            Object.defineProperty(wrapper, 'name', {\n                value: prop,\n                writable: false,\n                configurable: false,\n            });\n            return wrapper;\n        };\n        const addListener = createPluginMethodWrapper('addListener');\n        const removeListener = createPluginMethodWrapper('removeListener');\n        const addListenerNative = (eventName, callback) => {\n            const call = addListener({ eventName }, callback);\n            const remove = async () => {\n                const callbackId = await call;\n                removeListener({\n                    eventName,\n                    callbackId,\n                }, callback);\n            };\n            const p = new Promise((resolve) => call.then(() => resolve({ remove })));\n            p.remove = async () => {\n                console.warn(`Using addListener() without 'await' is deprecated.`);\n                await remove();\n            };\n            return p;\n        };\n        const proxy = new Proxy({}, {\n            get(_, prop) {\n                switch (prop) {\n                    // https://github.com/facebook/react/issues/20030\n                    case '$$typeof':\n                        return undefined;\n                    case 'toJSON':\n                        return () => ({});\n                    case 'addListener':\n                        return pluginHeader ? addListenerNative : addListener;\n                    case 'removeListener':\n                        return removeListener;\n                    default:\n                        return createPluginMethodWrapper(prop);\n                }\n            },\n        });\n        Plugins[pluginName] = proxy;\n        registeredPlugins.set(pluginName, {\n            name: pluginName,\n            proxy,\n            platforms: new Set([...Object.keys(jsImplementations), ...(pluginHeader ? [platform] : [])]),\n        });\n        return proxy;\n    };\n    // Add in convertFileSrc for web, it will already be available in native context\n    if (!cap.convertFileSrc) {\n        cap.convertFileSrc = (filePath) => filePath;\n    }\n    cap.getPlatform = getPlatform;\n    cap.handleError = handleError;\n    cap.isNativePlatform = isNativePlatform;\n    cap.isPluginAvailable = isPluginAvailable;\n    cap.registerPlugin = registerPlugin;\n    cap.Exception = CapacitorException;\n    cap.DEBUG = !!cap.DEBUG;\n    cap.isLoggingEnabled = !!cap.isLoggingEnabled;\n    return cap;\n};\nconst initCapacitorGlobal = (win) => (win.Capacitor = createCapacitor(win));\n\nconst Capacitor = /*#__PURE__*/ initCapacitorGlobal(typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n            ? window\n            : typeof global !== 'undefined'\n                ? global\n                : {});\nconst registerPlugin = Capacitor.registerPlugin;\n\n/**\n * Base class web plugins should extend.\n */\nclass WebPlugin {\n    constructor() {\n        this.listeners = {};\n        this.retainedEventArguments = {};\n        this.windowListeners = {};\n    }\n    addListener(eventName, listenerFunc) {\n        let firstListener = false;\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            this.listeners[eventName] = [];\n            firstListener = true;\n        }\n        this.listeners[eventName].push(listenerFunc);\n        // If we haven't added a window listener for this event and it requires one,\n        // go ahead and add it\n        const windowListener = this.windowListeners[eventName];\n        if (windowListener && !windowListener.registered) {\n            this.addWindowListener(windowListener);\n        }\n        if (firstListener) {\n            this.sendRetainedArgumentsForEvent(eventName);\n        }\n        const remove = async () => this.removeListener(eventName, listenerFunc);\n        const p = Promise.resolve({ remove });\n        return p;\n    }\n    async removeAllListeners() {\n        this.listeners = {};\n        for (const listener in this.windowListeners) {\n            this.removeWindowListener(this.windowListeners[listener]);\n        }\n        this.windowListeners = {};\n    }\n    notifyListeners(eventName, data, retainUntilConsumed) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            if (retainUntilConsumed) {\n                let args = this.retainedEventArguments[eventName];\n                if (!args) {\n                    args = [];\n                }\n                args.push(data);\n                this.retainedEventArguments[eventName] = args;\n            }\n            return;\n        }\n        listeners.forEach((listener) => listener(data));\n    }\n    hasListeners(eventName) {\n        var _a;\n        return !!((_a = this.listeners[eventName]) === null || _a === void 0 ? void 0 : _a.length);\n    }\n    registerWindowListener(windowEventName, pluginEventName) {\n        this.windowListeners[pluginEventName] = {\n            registered: false,\n            windowEventName,\n            pluginEventName,\n            handler: (event) => {\n                this.notifyListeners(pluginEventName, event);\n            },\n        };\n    }\n    unimplemented(msg = 'not implemented') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);\n    }\n    unavailable(msg = 'not available') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);\n    }\n    async removeListener(eventName, listenerFunc) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            return;\n        }\n        const index = listeners.indexOf(listenerFunc);\n        this.listeners[eventName].splice(index, 1);\n        // If there are no more listeners for this type of event,\n        // remove the window listener\n        if (!this.listeners[eventName].length) {\n            this.removeWindowListener(this.windowListeners[eventName]);\n        }\n    }\n    addWindowListener(handle) {\n        window.addEventListener(handle.windowEventName, handle.handler);\n        handle.registered = true;\n    }\n    removeWindowListener(handle) {\n        if (!handle) {\n            return;\n        }\n        window.removeEventListener(handle.windowEventName, handle.handler);\n        handle.registered = false;\n    }\n    sendRetainedArgumentsForEvent(eventName) {\n        const args = this.retainedEventArguments[eventName];\n        if (!args) {\n            return;\n        }\n        delete this.retainedEventArguments[eventName];\n        args.forEach((arg) => {\n            this.notifyListeners(eventName, arg);\n        });\n    }\n}\n\nconst WebView = /*#__PURE__*/ registerPlugin('WebView');\n/******** END WEB VIEW PLUGIN ********/\n/******** COOKIES PLUGIN ********/\n/**\n * Safely web encode a string value (inspired by js-cookie)\n * @param str The string value to encode\n */\nconst encode = (str) => encodeURIComponent(str)\n    .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n    .replace(/[()]/g, escape);\n/**\n * Safely web decode a string value (inspired by js-cookie)\n * @param str The string value to decode\n */\nconst decode = (str) => str.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent);\nclass CapacitorCookiesPluginWeb extends WebPlugin {\n    async getCookies() {\n        const cookies = document.cookie;\n        const cookieMap = {};\n        cookies.split(';').forEach((cookie) => {\n            if (cookie.length <= 0)\n                return;\n            // Replace first \"=\" with CAP_COOKIE to prevent splitting on additional \"=\"\n            let [key, value] = cookie.replace(/=/, 'CAP_COOKIE').split('CAP_COOKIE');\n            key = decode(key).trim();\n            value = decode(value).trim();\n            cookieMap[key] = value;\n        });\n        return cookieMap;\n    }\n    async setCookie(options) {\n        try {\n            // Safely Encoded Key/Value\n            const encodedKey = encode(options.key);\n            const encodedValue = encode(options.value);\n            // Clean & sanitize options\n            const expires = options.expires ? `; expires=${options.expires.replace('expires=', '')}` : '';\n            const path = (options.path || '/').replace('path=', ''); // Default is \"path=/\"\n            const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : '';\n            document.cookie = `${encodedKey}=${encodedValue || ''}${expires}; path=${path}; ${domain};`;\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async deleteCookie(options) {\n        try {\n            document.cookie = `${options.key}=; Max-Age=0`;\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async clearCookies() {\n        try {\n            const cookies = document.cookie.split(';') || [];\n            for (const cookie of cookies) {\n                document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);\n            }\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async clearAllCookies() {\n        try {\n            await this.clearCookies();\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n}\nconst CapacitorCookies = registerPlugin('CapacitorCookies', {\n    web: () => new CapacitorCookiesPluginWeb(),\n});\n// UTILITY FUNCTIONS\n/**\n * Read in a Blob value and return it as a base64 string\n * @param blob The blob value to convert to a base64 string\n */\nconst readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n        const base64String = reader.result;\n        // remove prefix \"data:application/pdf;base64,\"\n        resolve(base64String.indexOf(',') >= 0 ? base64String.split(',')[1] : base64String);\n    };\n    reader.onerror = (error) => reject(error);\n    reader.readAsDataURL(blob);\n});\n/**\n * Normalize an HttpHeaders map by lowercasing all of the values\n * @param headers The HttpHeaders object to normalize\n */\nconst normalizeHttpHeaders = (headers = {}) => {\n    const originalKeys = Object.keys(headers);\n    const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());\n    const normalized = loweredKeys.reduce((acc, key, index) => {\n        acc[key] = headers[originalKeys[index]];\n        return acc;\n    }, {});\n    return normalized;\n};\n/**\n * Builds a string of url parameters that\n * @param params A map of url parameters\n * @param shouldEncode true if you should encodeURIComponent() the values (true by default)\n */\nconst buildUrlParams = (params, shouldEncode = true) => {\n    if (!params)\n        return null;\n    const output = Object.entries(params).reduce((accumulator, entry) => {\n        const [key, value] = entry;\n        let encodedValue;\n        let item;\n        if (Array.isArray(value)) {\n            item = '';\n            value.forEach((str) => {\n                encodedValue = shouldEncode ? encodeURIComponent(str) : str;\n                item += `${key}=${encodedValue}&`;\n            });\n            // last character will always be \"&\" so slice it off\n            item.slice(0, -1);\n        }\n        else {\n            encodedValue = shouldEncode ? encodeURIComponent(value) : value;\n            item = `${key}=${encodedValue}`;\n        }\n        return `${accumulator}&${item}`;\n    }, '');\n    // Remove initial \"&\" from the reduce\n    return output.substr(1);\n};\n/**\n * Build the RequestInit object based on the options passed into the initial request\n * @param options The Http plugin options\n * @param extra Any extra RequestInit values\n */\nconst buildRequestInit = (options, extra = {}) => {\n    const output = Object.assign({ method: options.method || 'GET', headers: options.headers }, extra);\n    // Get the content-type\n    const headers = normalizeHttpHeaders(options.headers);\n    const type = headers['content-type'] || '';\n    // If body is already a string, then pass it through as-is.\n    if (typeof options.data === 'string') {\n        output.body = options.data;\n    }\n    // Build request initializers based off of content-type\n    else if (type.includes('application/x-www-form-urlencoded')) {\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(options.data || {})) {\n            params.set(key, value);\n        }\n        output.body = params.toString();\n    }\n    else if (type.includes('multipart/form-data') || options.data instanceof FormData) {\n        const form = new FormData();\n        if (options.data instanceof FormData) {\n            options.data.forEach((value, key) => {\n                form.append(key, value);\n            });\n        }\n        else {\n            for (const key of Object.keys(options.data)) {\n                form.append(key, options.data[key]);\n            }\n        }\n        output.body = form;\n        const headers = new Headers(output.headers);\n        headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary\n        output.headers = headers;\n    }\n    else if (type.includes('application/json') || typeof options.data === 'object') {\n        output.body = JSON.stringify(options.data);\n    }\n    return output;\n};\n// WEB IMPLEMENTATION\nclass CapacitorHttpPluginWeb extends WebPlugin {\n    /**\n     * Perform an Http request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async request(options) {\n        const requestInit = buildRequestInit(options, options.webFetchExtra);\n        const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);\n        const url = urlParams ? `${options.url}?${urlParams}` : options.url;\n        const response = await fetch(url, requestInit);\n        const contentType = response.headers.get('content-type') || '';\n        // Default to 'text' responseType so no parsing happens\n        let { responseType = 'text' } = response.ok ? options : {};\n        // If the response content-type is json, force the response to be json\n        if (contentType.includes('application/json')) {\n            responseType = 'json';\n        }\n        let data;\n        let blob;\n        switch (responseType) {\n            case 'arraybuffer':\n            case 'blob':\n                blob = await response.blob();\n                data = await readBlobAsBase64(blob);\n                break;\n            case 'json':\n                data = await response.json();\n                break;\n            case 'document':\n            case 'text':\n            default:\n                data = await response.text();\n        }\n        // Convert fetch headers to Capacitor HttpHeaders\n        const headers = {};\n        response.headers.forEach((value, key) => {\n            headers[key] = value;\n        });\n        return {\n            data,\n            headers,\n            status: response.status,\n            url: response.url,\n        };\n    }\n    /**\n     * Perform an Http GET request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async get(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'GET' }));\n    }\n    /**\n     * Perform an Http POST request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async post(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'POST' }));\n    }\n    /**\n     * Perform an Http PUT request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async put(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'PUT' }));\n    }\n    /**\n     * Perform an Http PATCH request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async patch(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'PATCH' }));\n    }\n    /**\n     * Perform an Http DELETE request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async delete(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'DELETE' }));\n    }\n}\nconst CapacitorHttp = registerPlugin('CapacitorHttp', {\n    web: () => new CapacitorHttpPluginWeb(),\n});\n/******** END HTTP PLUGIN ********/\n/******** SYSTEM BARS PLUGIN ********/\n/**\n * Available status bar styles.\n */\nvar SystemBarsStyle;\n(function (SystemBarsStyle) {\n    /**\n     * Light system bar content on a dark background.\n     *\n     * @since 8.0.0\n     */\n    SystemBarsStyle[\"Dark\"] = \"DARK\";\n    /**\n     * For dark system bar content on a light background.\n     *\n     * @since 8.0.0\n     */\n    SystemBarsStyle[\"Light\"] = \"LIGHT\";\n    /**\n     * The style is based on the device appearance or the underlying content.\n     * If the device is using Dark mode, the system bars content will be light.\n     * If the device is using Light mode, the system bars content will be dark.\n     *\n     * @since 8.0.0\n     */\n    SystemBarsStyle[\"Default\"] = \"DEFAULT\";\n})(SystemBarsStyle || (SystemBarsStyle = {}));\n/**\n * Available system bar types.\n */\nvar SystemBarType;\n(function (SystemBarType) {\n    /**\n     * The top status bar on both Android and iOS.\n     *\n     * @since 8.0.0\n     */\n    SystemBarType[\"StatusBar\"] = \"StatusBar\";\n    /**\n     * The navigation bar (or gesture bar on iOS) on both Android and iOS.\n     *\n     * @since 8.0.0\n     */\n    SystemBarType[\"NavigationBar\"] = \"NavigationBar\";\n})(SystemBarType || (SystemBarType = {}));\nclass SystemBarsPluginWeb extends WebPlugin {\n    async setStyle() {\n        this.unavailable('not available for web');\n    }\n    async setAnimation() {\n        this.unavailable('not available for web');\n    }\n    async show() {\n        this.unavailable('not available for web');\n    }\n    async hide() {\n        this.unavailable('not available for web');\n    }\n}\nconst SystemBars = registerPlugin('SystemBars', {\n    web: () => new SystemBarsPluginWeb(),\n});\n/******** END SYSTEM BARS PLUGIN ********/\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXLGlDQUFpQyxTQUFTO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVcsR0FBRyxLQUFLLDRCQUE0QixTQUFTO0FBQ2pIO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0IsS0FBSyxrQkFBa0I7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LGNBQWMsaUJBQWlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjLGtCQUFrQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRTJMO0FBQzNMIiwic291cmNlcyI6WyIvaG9tZS91c2VyL3N0dWRpby9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci9jb3JlL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIENhcGFjaXRvcjogaHR0cHM6Ly9jYXBhY2l0b3Jqcy5jb20vIC0gTUlUIExpY2Vuc2UgKi9cbnZhciBFeGNlcHRpb25Db2RlO1xuKGZ1bmN0aW9uIChFeGNlcHRpb25Db2RlKSB7XG4gICAgLyoqXG4gICAgICogQVBJIGlzIG5vdCBpbXBsZW1lbnRlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgdXN1YWxseSBtZWFucyB0aGUgQVBJIGNhbid0IGJlIHVzZWQgYmVjYXVzZSBpdCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yXG4gICAgICogdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gICAgICovXG4gICAgRXhjZXB0aW9uQ29kZVtcIlVuaW1wbGVtZW50ZWRcIl0gPSBcIlVOSU1QTEVNRU5URURcIjtcbiAgICAvKipcbiAgICAgKiBBUEkgaXMgbm90IGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWVhbnMgdGhlIEFQSSBjYW4ndCBiZSB1c2VkIHJpZ2h0IG5vdyBiZWNhdXNlOlxuICAgICAqICAgLSBpdCBpcyBjdXJyZW50bHkgbWlzc2luZyBhIHByZXJlcXVpc2l0ZSwgc3VjaCBhcyBuZXR3b3JrIGNvbm5lY3Rpdml0eVxuICAgICAqICAgLSBpdCByZXF1aXJlcyBhIHBhcnRpY3VsYXIgcGxhdGZvcm0gb3IgYnJvd3NlciB2ZXJzaW9uXG4gICAgICovXG4gICAgRXhjZXB0aW9uQ29kZVtcIlVuYXZhaWxhYmxlXCJdID0gXCJVTkFWQUlMQUJMRVwiO1xufSkoRXhjZXB0aW9uQ29kZSB8fCAoRXhjZXB0aW9uQ29kZSA9IHt9KSk7XG5jbGFzcyBDYXBhY2l0b3JFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgZGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59XG5jb25zdCBnZXRQbGF0Zm9ybUlkID0gKHdpbikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5hbmRyb2lkQnJpZGdlKSB7XG4gICAgICAgIHJldHVybiAnYW5kcm9pZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKChfYiA9IChfYSA9IHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi53ZWJraXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlSGFuZGxlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5icmlkZ2UpIHtcbiAgICAgICAgcmV0dXJuICdpb3MnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICd3ZWInO1xuICAgIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUNhcGFjaXRvciA9ICh3aW4pID0+IHtcbiAgICBjb25zdCBjYXBDdXN0b21QbGF0Zm9ybSA9IHdpbi5DYXBhY2l0b3JDdXN0b21QbGF0Zm9ybSB8fCBudWxsO1xuICAgIGNvbnN0IGNhcCA9IHdpbi5DYXBhY2l0b3IgfHwge307XG4gICAgY29uc3QgUGx1Z2lucyA9IChjYXAuUGx1Z2lucyA9IGNhcC5QbHVnaW5zIHx8IHt9KTtcbiAgICBjb25zdCBnZXRQbGF0Zm9ybSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNhcEN1c3RvbVBsYXRmb3JtICE9PSBudWxsID8gY2FwQ3VzdG9tUGxhdGZvcm0ubmFtZSA6IGdldFBsYXRmb3JtSWQod2luKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTmF0aXZlUGxhdGZvcm0gPSAoKSA9PiBnZXRQbGF0Zm9ybSgpICE9PSAnd2ViJztcbiAgICBjb25zdCBpc1BsdWdpbkF2YWlsYWJsZSA9IChwbHVnaW5OYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHJlZ2lzdGVyZWRQbHVnaW5zLmdldChwbHVnaW5OYW1lKTtcbiAgICAgICAgaWYgKHBsdWdpbiA9PT0gbnVsbCB8fCBwbHVnaW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBsdWdpbi5wbGF0Zm9ybXMuaGFzKGdldFBsYXRmb3JtKCkpKSB7XG4gICAgICAgICAgICAvLyBKUyBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGUgZm9yIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFBsdWdpbkhlYWRlcihwbHVnaW5OYW1lKSkge1xuICAgICAgICAgICAgLy8gTmF0aXZlIGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFBsdWdpbkhlYWRlciA9IChwbHVnaW5OYW1lKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGNhcC5QbHVnaW5IZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoaCkgPT4gaC5uYW1lID09PSBwbHVnaW5OYW1lKTsgfTtcbiAgICBjb25zdCBoYW5kbGVFcnJvciA9IChlcnIpID0+IHdpbi5jb25zb2xlLmVycm9yKGVycik7XG4gICAgY29uc3QgcmVnaXN0ZXJlZFBsdWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcmVnaXN0ZXJQbHVnaW4gPSAocGx1Z2luTmFtZSwganNJbXBsZW1lbnRhdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCByZWdpc3RlcmVkUGx1Z2luID0gcmVnaXN0ZXJlZFBsdWdpbnMuZ2V0KHBsdWdpbk5hbWUpO1xuICAgICAgICBpZiAocmVnaXN0ZXJlZFBsdWdpbikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDYXBhY2l0b3IgcGx1Z2luIFwiJHtwbHVnaW5OYW1lfVwiIGFscmVhZHkgcmVnaXN0ZXJlZC4gQ2Fubm90IHJlZ2lzdGVyIHBsdWdpbnMgdHdpY2UuYCk7XG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFBsdWdpbi5wcm94eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGF0Zm9ybSA9IGdldFBsYXRmb3JtKCk7XG4gICAgICAgIGNvbnN0IHBsdWdpbkhlYWRlciA9IGdldFBsdWdpbkhlYWRlcihwbHVnaW5OYW1lKTtcbiAgICAgICAgbGV0IGpzSW1wbGVtZW50YXRpb247XG4gICAgICAgIGNvbnN0IGxvYWRQbHVnaW5JbXBsZW1lbnRhdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghanNJbXBsZW1lbnRhdGlvbiAmJiBwbGF0Zm9ybSBpbiBqc0ltcGxlbWVudGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGpzSW1wbGVtZW50YXRpb24gPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YganNJbXBsZW1lbnRhdGlvbnNbcGxhdGZvcm1dID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChqc0ltcGxlbWVudGF0aW9uID0gYXdhaXQganNJbXBsZW1lbnRhdGlvbnNbcGxhdGZvcm1dKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChqc0ltcGxlbWVudGF0aW9uID0ganNJbXBsZW1lbnRhdGlvbnNbcGxhdGZvcm1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNhcEN1c3RvbVBsYXRmb3JtICE9PSBudWxsICYmICFqc0ltcGxlbWVudGF0aW9uICYmICd3ZWInIGluIGpzSW1wbGVtZW50YXRpb25zKSB7XG4gICAgICAgICAgICAgICAganNJbXBsZW1lbnRhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBqc0ltcGxlbWVudGF0aW9uc1snd2ViJ10gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKGpzSW1wbGVtZW50YXRpb24gPSBhd2FpdCBqc0ltcGxlbWVudGF0aW9uc1snd2ViJ10oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGpzSW1wbGVtZW50YXRpb24gPSBqc0ltcGxlbWVudGF0aW9uc1snd2ViJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpzSW1wbGVtZW50YXRpb247XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNyZWF0ZVBsdWdpbk1ldGhvZCA9IChpbXBsLCBwcm9wKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKHBsdWdpbkhlYWRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGhvZEhlYWRlciA9IHBsdWdpbkhlYWRlciA9PT0gbnVsbCB8fCBwbHVnaW5IZWFkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBsdWdpbkhlYWRlci5tZXRob2RzLmZpbmQoKG0pID0+IHByb3AgPT09IG0ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZEhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kSGVhZGVyLnJ0eXBlID09PSAncHJvbWlzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAob3B0aW9ucykgPT4gY2FwLm5hdGl2ZVByb21pc2UocGx1Z2luTmFtZSwgcHJvcC50b1N0cmluZygpLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAob3B0aW9ucywgY2FsbGJhY2spID0+IGNhcC5uYXRpdmVDYWxsYmFjayhwbHVnaW5OYW1lLCBwcm9wLnRvU3RyaW5nKCksIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbXBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSBpbXBsW3Byb3BdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChpbXBsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbXBsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYiA9IGltcGxbcHJvcF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5iaW5kKGltcGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENhcGFjaXRvckV4Y2VwdGlvbihgXCIke3BsdWdpbk5hbWV9XCIgcGx1Z2luIGlzIG5vdCBpbXBsZW1lbnRlZCBvbiAke3BsYXRmb3JtfWAsIEV4Y2VwdGlvbkNvZGUuVW5pbXBsZW1lbnRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNyZWF0ZVBsdWdpbk1ldGhvZFdyYXBwZXIgPSAocHJvcCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlbW92ZTtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBsb2FkUGx1Z2luSW1wbGVtZW50YXRpb24oKS50aGVuKChpbXBsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZuID0gY3JlYXRlUGx1Z2luTWV0aG9kKGltcGwsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBmbiguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IHAgPT09IG51bGwgfHwgcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcC5yZW1vdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDYXBhY2l0b3JFeGNlcHRpb24oYFwiJHtwbHVnaW5OYW1lfS4ke3Byb3B9KClcIiBpcyBub3QgaW1wbGVtZW50ZWQgb24gJHtwbGF0Zm9ybX1gLCBFeGNlcHRpb25Db2RlLlVuaW1wbGVtZW50ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdhZGRMaXN0ZW5lcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcC5yZW1vdmUgPSBhc3luYyAoKSA9PiByZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gU29tZSBmbGFpciDinKhcbiAgICAgICAgICAgIHdyYXBwZXIudG9TdHJpbmcgPSAoKSA9PiBgJHtwcm9wLnRvU3RyaW5nKCl9KCkgeyBbY2FwYWNpdG9yIGNvZGVdIH1gO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdyYXBwZXIsICduYW1lJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWRkTGlzdGVuZXIgPSBjcmVhdGVQbHVnaW5NZXRob2RXcmFwcGVyKCdhZGRMaXN0ZW5lcicpO1xuICAgICAgICBjb25zdCByZW1vdmVMaXN0ZW5lciA9IGNyZWF0ZVBsdWdpbk1ldGhvZFdyYXBwZXIoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIGNvbnN0IGFkZExpc3RlbmVyTmF0aXZlID0gKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSBhZGRMaXN0ZW5lcih7IGV2ZW50TmFtZSB9LCBjYWxsYmFjayk7XG4gICAgICAgICAgICBjb25zdCByZW1vdmUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tJZCA9IGF3YWl0IGNhbGw7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrSWQsXG4gICAgICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gY2FsbC50aGVuKCgpID0+IHJlc29sdmUoeyByZW1vdmUgfSkpKTtcbiAgICAgICAgICAgIHAucmVtb3ZlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVXNpbmcgYWRkTGlzdGVuZXIoKSB3aXRob3V0ICdhd2FpdCcgaXMgZGVwcmVjYXRlZC5gKTtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldChfLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAwMzBcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnJCR0eXBlb2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9KU09OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiAoe30pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhZGRMaXN0ZW5lcic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luSGVhZGVyID8gYWRkTGlzdGVuZXJOYXRpdmUgOiBhZGRMaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVtb3ZlTGlzdGVuZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBsdWdpbk1ldGhvZFdyYXBwZXIocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIFBsdWdpbnNbcGx1Z2luTmFtZV0gPSBwcm94eTtcbiAgICAgICAgcmVnaXN0ZXJlZFBsdWdpbnMuc2V0KHBsdWdpbk5hbWUsIHtcbiAgICAgICAgICAgIG5hbWU6IHBsdWdpbk5hbWUsXG4gICAgICAgICAgICBwcm94eSxcbiAgICAgICAgICAgIHBsYXRmb3JtczogbmV3IFNldChbLi4uT2JqZWN0LmtleXMoanNJbXBsZW1lbnRhdGlvbnMpLCAuLi4ocGx1Z2luSGVhZGVyID8gW3BsYXRmb3JtXSA6IFtdKV0pLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH07XG4gICAgLy8gQWRkIGluIGNvbnZlcnRGaWxlU3JjIGZvciB3ZWIsIGl0IHdpbGwgYWxyZWFkeSBiZSBhdmFpbGFibGUgaW4gbmF0aXZlIGNvbnRleHRcbiAgICBpZiAoIWNhcC5jb252ZXJ0RmlsZVNyYykge1xuICAgICAgICBjYXAuY29udmVydEZpbGVTcmMgPSAoZmlsZVBhdGgpID0+IGZpbGVQYXRoO1xuICAgIH1cbiAgICBjYXAuZ2V0UGxhdGZvcm0gPSBnZXRQbGF0Zm9ybTtcbiAgICBjYXAuaGFuZGxlRXJyb3IgPSBoYW5kbGVFcnJvcjtcbiAgICBjYXAuaXNOYXRpdmVQbGF0Zm9ybSA9IGlzTmF0aXZlUGxhdGZvcm07XG4gICAgY2FwLmlzUGx1Z2luQXZhaWxhYmxlID0gaXNQbHVnaW5BdmFpbGFibGU7XG4gICAgY2FwLnJlZ2lzdGVyUGx1Z2luID0gcmVnaXN0ZXJQbHVnaW47XG4gICAgY2FwLkV4Y2VwdGlvbiA9IENhcGFjaXRvckV4Y2VwdGlvbjtcbiAgICBjYXAuREVCVUcgPSAhIWNhcC5ERUJVRztcbiAgICBjYXAuaXNMb2dnaW5nRW5hYmxlZCA9ICEhY2FwLmlzTG9nZ2luZ0VuYWJsZWQ7XG4gICAgcmV0dXJuIGNhcDtcbn07XG5jb25zdCBpbml0Q2FwYWNpdG9yR2xvYmFsID0gKHdpbikgPT4gKHdpbi5DYXBhY2l0b3IgPSBjcmVhdGVDYXBhY2l0b3Iod2luKSk7XG5cbmNvbnN0IENhcGFjaXRvciA9IC8qI19fUFVSRV9fKi8gaW5pdENhcGFjaXRvckdsb2JhbCh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IGdsb2JhbFRoaXNcbiAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHNlbGZcbiAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyB3aW5kb3dcbiAgICAgICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFxuICAgICAgICAgICAgICAgIDoge30pO1xuY29uc3QgcmVnaXN0ZXJQbHVnaW4gPSBDYXBhY2l0b3IucmVnaXN0ZXJQbHVnaW47XG5cbi8qKlxuICogQmFzZSBjbGFzcyB3ZWIgcGx1Z2lucyBzaG91bGQgZXh0ZW5kLlxuICovXG5jbGFzcyBXZWJQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgICAgICB0aGlzLnJldGFpbmVkRXZlbnRBcmd1bWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lckZ1bmMpIHtcbiAgICAgICAgbGV0IGZpcnN0TGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgICAgIGZpcnN0TGlzdGVuZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lckZ1bmMpO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IGFkZGVkIGEgd2luZG93IGxpc3RlbmVyIGZvciB0aGlzIGV2ZW50IGFuZCBpdCByZXF1aXJlcyBvbmUsXG4gICAgICAgIC8vIGdvIGFoZWFkIGFuZCBhZGQgaXRcbiAgICAgICAgY29uc3Qgd2luZG93TGlzdGVuZXIgPSB0aGlzLndpbmRvd0xpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgICAgICBpZiAod2luZG93TGlzdGVuZXIgJiYgIXdpbmRvd0xpc3RlbmVyLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93TGlzdGVuZXIod2luZG93TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRSZXRhaW5lZEFyZ3VtZW50c0ZvckV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtb3ZlID0gYXN5bmMgKCkgPT4gdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyRnVuYyk7XG4gICAgICAgIGNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUoeyByZW1vdmUgfSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgaW4gdGhpcy53aW5kb3dMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXIodGhpcy53aW5kb3dMaXN0ZW5lcnNbbGlzdGVuZXJdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpbmRvd0xpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBub3RpZnlMaXN0ZW5lcnMoZXZlbnROYW1lLCBkYXRhLCByZXRhaW5VbnRpbENvbnN1bWVkKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZiAocmV0YWluVW50aWxDb25zdW1lZCkge1xuICAgICAgICAgICAgICAgIGxldCBhcmdzID0gdGhpcy5yZXRhaW5lZEV2ZW50QXJndW1lbnRzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMucmV0YWluZWRFdmVudEFyZ3VtZW50c1tldmVudE5hbWVdID0gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGRhdGEpKTtcbiAgICB9XG4gICAgaGFzTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAhISgoX2EgPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJXaW5kb3dMaXN0ZW5lcih3aW5kb3dFdmVudE5hbWUsIHBsdWdpbkV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLndpbmRvd0xpc3RlbmVyc1twbHVnaW5FdmVudE5hbWVdID0ge1xuICAgICAgICAgICAgcmVnaXN0ZXJlZDogZmFsc2UsXG4gICAgICAgICAgICB3aW5kb3dFdmVudE5hbWUsXG4gICAgICAgICAgICBwbHVnaW5FdmVudE5hbWUsXG4gICAgICAgICAgICBoYW5kbGVyOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhwbHVnaW5FdmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHVuaW1wbGVtZW50ZWQobXNnID0gJ25vdCBpbXBsZW1lbnRlZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXBhY2l0b3IuRXhjZXB0aW9uKG1zZywgRXhjZXB0aW9uQ29kZS5VbmltcGxlbWVudGVkKTtcbiAgICB9XG4gICAgdW5hdmFpbGFibGUobXNnID0gJ25vdCBhdmFpbGFibGUnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FwYWNpdG9yLkV4Y2VwdGlvbihtc2csIEV4Y2VwdGlvbkNvZGUuVW5hdmFpbGFibGUpO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyRnVuYykge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXJGdW5jKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbW9yZSBsaXN0ZW5lcnMgZm9yIHRoaXMgdHlwZSBvZiBldmVudCxcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB3aW5kb3cgbGlzdGVuZXJcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcih0aGlzLndpbmRvd0xpc3RlbmVyc1tldmVudE5hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRXaW5kb3dMaXN0ZW5lcihoYW5kbGUpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoaGFuZGxlLndpbmRvd0V2ZW50TmFtZSwgaGFuZGxlLmhhbmRsZXIpO1xuICAgICAgICBoYW5kbGUucmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJlbW92ZVdpbmRvd0xpc3RlbmVyKGhhbmRsZSkge1xuICAgICAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGhhbmRsZS53aW5kb3dFdmVudE5hbWUsIGhhbmRsZS5oYW5kbGVyKTtcbiAgICAgICAgaGFuZGxlLnJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgc2VuZFJldGFpbmVkQXJndW1lbnRzRm9yRXZlbnQoZXZlbnROYW1lKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnJldGFpbmVkRXZlbnRBcmd1bWVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMucmV0YWluZWRFdmVudEFyZ3VtZW50c1tldmVudE5hbWVdO1xuICAgICAgICBhcmdzLmZvckVhY2goKGFyZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoZXZlbnROYW1lLCBhcmcpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IFdlYlZpZXcgPSAvKiNfX1BVUkVfXyovIHJlZ2lzdGVyUGx1Z2luKCdXZWJWaWV3Jyk7XG4vKioqKioqKiogRU5EIFdFQiBWSUVXIFBMVUdJTiAqKioqKioqKi9cbi8qKioqKioqKiBDT09LSUVTIFBMVUdJTiAqKioqKioqKi9cbi8qKlxuICogU2FmZWx5IHdlYiBlbmNvZGUgYSBzdHJpbmcgdmFsdWUgKGluc3BpcmVkIGJ5IGpzLWNvb2tpZSlcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB2YWx1ZSB0byBlbmNvZGVcbiAqL1xuY29uc3QgZW5jb2RlID0gKHN0cikgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgICAucmVwbGFjZSgvJSgyWzM0NkJdfDVFfDYwfDdDKS9nLCBkZWNvZGVVUklDb21wb25lbnQpXG4gICAgLnJlcGxhY2UoL1soKV0vZywgZXNjYXBlKTtcbi8qKlxuICogU2FmZWx5IHdlYiBkZWNvZGUgYSBzdHJpbmcgdmFsdWUgKGluc3BpcmVkIGJ5IGpzLWNvb2tpZSlcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB2YWx1ZSB0byBkZWNvZGVcbiAqL1xuY29uc3QgZGVjb2RlID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoLyglW1xcZEEtRl17Mn0pKy9naSwgZGVjb2RlVVJJQ29tcG9uZW50KTtcbmNsYXNzIENhcGFjaXRvckNvb2tpZXNQbHVnaW5XZWIgZXh0ZW5kcyBXZWJQbHVnaW4ge1xuICAgIGFzeW5jIGdldENvb2tpZXMoKSB7XG4gICAgICAgIGNvbnN0IGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWU7XG4gICAgICAgIGNvbnN0IGNvb2tpZU1hcCA9IHt9O1xuICAgICAgICBjb29raWVzLnNwbGl0KCc7JykuZm9yRWFjaCgoY29va2llKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29va2llLmxlbmd0aCA8PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgZmlyc3QgXCI9XCIgd2l0aCBDQVBfQ09PS0lFIHRvIHByZXZlbnQgc3BsaXR0aW5nIG9uIGFkZGl0aW9uYWwgXCI9XCJcbiAgICAgICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBjb29raWUucmVwbGFjZSgvPS8sICdDQVBfQ09PS0lFJykuc3BsaXQoJ0NBUF9DT09LSUUnKTtcbiAgICAgICAgICAgIGtleSA9IGRlY29kZShrZXkpLnRyaW0oKTtcbiAgICAgICAgICAgIHZhbHVlID0gZGVjb2RlKHZhbHVlKS50cmltKCk7XG4gICAgICAgICAgICBjb29raWVNYXBba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvb2tpZU1hcDtcbiAgICB9XG4gICAgYXN5bmMgc2V0Q29va2llKG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFNhZmVseSBFbmNvZGVkIEtleS9WYWx1ZVxuICAgICAgICAgICAgY29uc3QgZW5jb2RlZEtleSA9IGVuY29kZShvcHRpb25zLmtleSk7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkVmFsdWUgPSBlbmNvZGUob3B0aW9ucy52YWx1ZSk7XG4gICAgICAgICAgICAvLyBDbGVhbiAmIHNhbml0aXplIG9wdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZXMgPSBvcHRpb25zLmV4cGlyZXMgPyBgOyBleHBpcmVzPSR7b3B0aW9ucy5leHBpcmVzLnJlcGxhY2UoJ2V4cGlyZXM9JywgJycpfWAgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSAob3B0aW9ucy5wYXRoIHx8ICcvJykucmVwbGFjZSgncGF0aD0nLCAnJyk7IC8vIERlZmF1bHQgaXMgXCJwYXRoPS9cIlxuICAgICAgICAgICAgY29uc3QgZG9tYWluID0gb3B0aW9ucy51cmwgIT0gbnVsbCAmJiBvcHRpb25zLnVybC5sZW5ndGggPiAwID8gYGRvbWFpbj0ke29wdGlvbnMudXJsfWAgOiAnJztcbiAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke2VuY29kZWRLZXl9PSR7ZW5jb2RlZFZhbHVlIHx8ICcnfSR7ZXhwaXJlc307IHBhdGg9JHtwYXRofTsgJHtkb21haW59O2A7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUNvb2tpZShvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtvcHRpb25zLmtleX09OyBNYXgtQWdlPTBgO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjbGVhckNvb2tpZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7JykgfHwgW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiBjb29raWVzKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLnJlcGxhY2UoL14gKy8sICcnKS5yZXBsYWNlKC89LiovLCBgPTtleHBpcmVzPSR7bmV3IERhdGUoKS50b1VUQ1N0cmluZygpfTtwYXRoPS9gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY2xlYXJBbGxDb29raWVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhckNvb2tpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBDYXBhY2l0b3JDb29raWVzID0gcmVnaXN0ZXJQbHVnaW4oJ0NhcGFjaXRvckNvb2tpZXMnLCB7XG4gICAgd2ViOiAoKSA9PiBuZXcgQ2FwYWNpdG9yQ29va2llc1BsdWdpbldlYigpLFxufSk7XG4vLyBVVElMSVRZIEZVTkNUSU9OU1xuLyoqXG4gKiBSZWFkIGluIGEgQmxvYiB2YWx1ZSBhbmQgcmV0dXJuIGl0IGFzIGEgYmFzZTY0IHN0cmluZ1xuICogQHBhcmFtIGJsb2IgVGhlIGJsb2IgdmFsdWUgdG8gY29udmVydCB0byBhIGJhc2U2NCBzdHJpbmdcbiAqL1xuY29uc3QgcmVhZEJsb2JBc0Jhc2U2NCA9IGFzeW5jIChibG9iKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlNjRTdHJpbmcgPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAvLyByZW1vdmUgcHJlZml4IFwiZGF0YTphcHBsaWNhdGlvbi9wZGY7YmFzZTY0LFwiXG4gICAgICAgIHJlc29sdmUoYmFzZTY0U3RyaW5nLmluZGV4T2YoJywnKSA+PSAwID8gYmFzZTY0U3RyaW5nLnNwbGl0KCcsJylbMV0gOiBiYXNlNjRTdHJpbmcpO1xuICAgIH07XG4gICAgcmVhZGVyLm9uZXJyb3IgPSAoZXJyb3IpID0+IHJlamVjdChlcnJvcik7XG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG59KTtcbi8qKlxuICogTm9ybWFsaXplIGFuIEh0dHBIZWFkZXJzIG1hcCBieSBsb3dlcmNhc2luZyBhbGwgb2YgdGhlIHZhbHVlc1xuICogQHBhcmFtIGhlYWRlcnMgVGhlIEh0dHBIZWFkZXJzIG9iamVjdCB0byBub3JtYWxpemVcbiAqL1xuY29uc3Qgbm9ybWFsaXplSHR0cEhlYWRlcnMgPSAoaGVhZGVycyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgY29uc3QgbG93ZXJlZEtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKS5tYXAoKGspID0+IGsudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGxvd2VyZWRLZXlzLnJlZHVjZSgoYWNjLCBrZXksIGluZGV4KSA9PiB7XG4gICAgICAgIGFjY1trZXldID0gaGVhZGVyc1tvcmlnaW5hbEtleXNbaW5kZXhdXTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuLyoqXG4gKiBCdWlsZHMgYSBzdHJpbmcgb2YgdXJsIHBhcmFtZXRlcnMgdGhhdFxuICogQHBhcmFtIHBhcmFtcyBBIG1hcCBvZiB1cmwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHNob3VsZEVuY29kZSB0cnVlIGlmIHlvdSBzaG91bGQgZW5jb2RlVVJJQ29tcG9uZW50KCkgdGhlIHZhbHVlcyAodHJ1ZSBieSBkZWZhdWx0KVxuICovXG5jb25zdCBidWlsZFVybFBhcmFtcyA9IChwYXJhbXMsIHNob3VsZEVuY29kZSA9IHRydWUpID0+IHtcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmVudHJpZXMocGFyYW1zKS5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBlbnRyeSkgPT4ge1xuICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBlbnRyeTtcbiAgICAgICAgbGV0IGVuY29kZWRWYWx1ZTtcbiAgICAgICAgbGV0IGl0ZW07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaXRlbSA9ICcnO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgoc3RyKSA9PiB7XG4gICAgICAgICAgICAgICAgZW5jb2RlZFZhbHVlID0gc2hvdWxkRW5jb2RlID8gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikgOiBzdHI7XG4gICAgICAgICAgICAgICAgaXRlbSArPSBgJHtrZXl9PSR7ZW5jb2RlZFZhbHVlfSZgO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBsYXN0IGNoYXJhY3RlciB3aWxsIGFsd2F5cyBiZSBcIiZcIiBzbyBzbGljZSBpdCBvZmZcbiAgICAgICAgICAgIGl0ZW0uc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5jb2RlZFZhbHVlID0gc2hvdWxkRW5jb2RlID8gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgaXRlbSA9IGAke2tleX09JHtlbmNvZGVkVmFsdWV9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7YWNjdW11bGF0b3J9JiR7aXRlbX1gO1xuICAgIH0sICcnKTtcbiAgICAvLyBSZW1vdmUgaW5pdGlhbCBcIiZcIiBmcm9tIHRoZSByZWR1Y2VcbiAgICByZXR1cm4gb3V0cHV0LnN1YnN0cigxKTtcbn07XG4vKipcbiAqIEJ1aWxkIHRoZSBSZXF1ZXN0SW5pdCBvYmplY3QgYmFzZWQgb24gdGhlIG9wdGlvbnMgcGFzc2VkIGludG8gdGhlIGluaXRpYWwgcmVxdWVzdFxuICogQHBhcmFtIG9wdGlvbnMgVGhlIEh0dHAgcGx1Z2luIG9wdGlvbnNcbiAqIEBwYXJhbSBleHRyYSBBbnkgZXh0cmEgUmVxdWVzdEluaXQgdmFsdWVzXG4gKi9cbmNvbnN0IGJ1aWxkUmVxdWVzdEluaXQgPSAob3B0aW9ucywgZXh0cmEgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLCBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMgfSwgZXh0cmEpO1xuICAgIC8vIEdldCB0aGUgY29udGVudC10eXBlXG4gICAgY29uc3QgaGVhZGVycyA9IG5vcm1hbGl6ZUh0dHBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgdHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICAgIC8vIElmIGJvZHkgaXMgYWxyZWFkeSBhIHN0cmluZywgdGhlbiBwYXNzIGl0IHRocm91Z2ggYXMtaXMuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG91dHB1dC5ib2R5ID0gb3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICAvLyBCdWlsZCByZXF1ZXN0IGluaXRpYWxpemVycyBiYXNlZCBvZmYgb2YgY29udGVudC10eXBlXG4gICAgZWxzZSBpZiAodHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLmRhdGEgfHwge30pKSB7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5ib2R5ID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuaW5jbHVkZXMoJ211bHRpcGFydC9mb3JtLWRhdGEnKSB8fCBvcHRpb25zLmRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0aW9ucy5kYXRhKSkge1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGtleSwgb3B0aW9ucy5kYXRhW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5ib2R5ID0gZm9ybTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKG91dHB1dC5oZWFkZXJzKTtcbiAgICAgICAgaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtdHlwZScpOyAvLyBjb250ZW50LXR5cGUgd2lsbCBiZSBzZXQgYnkgYHdpbmRvdy5mZXRjaGAgdG8gaW5jbHVkeSBib3VuZGFyeVxuICAgICAgICBvdXRwdXQuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSB8fCB0eXBlb2Ygb3B0aW9ucy5kYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvdXRwdXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuLy8gV0VCIElNUExFTUVOVEFUSU9OXG5jbGFzcyBDYXBhY2l0b3JIdHRwUGx1Z2luV2ViIGV4dGVuZHMgV2ViUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIEh0dHAgcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBidWlsZCB0aGUgSFRUUCByZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgcmVxdWVzdChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJbml0ID0gYnVpbGRSZXF1ZXN0SW5pdChvcHRpb25zLCBvcHRpb25zLndlYkZldGNoRXh0cmEpO1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBidWlsZFVybFBhcmFtcyhvcHRpb25zLnBhcmFtcywgb3B0aW9ucy5zaG91bGRFbmNvZGVVcmxQYXJhbXMpO1xuICAgICAgICBjb25zdCB1cmwgPSB1cmxQYXJhbXMgPyBgJHtvcHRpb25zLnVybH0/JHt1cmxQYXJhbXN9YCA6IG9wdGlvbnMudXJsO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgcmVxdWVzdEluaXQpO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJztcbiAgICAgICAgLy8gRGVmYXVsdCB0byAndGV4dCcgcmVzcG9uc2VUeXBlIHNvIG5vIHBhcnNpbmcgaGFwcGVuc1xuICAgICAgICBsZXQgeyByZXNwb25zZVR5cGUgPSAndGV4dCcgfSA9IHJlc3BvbnNlLm9rID8gb3B0aW9ucyA6IHt9O1xuICAgICAgICAvLyBJZiB0aGUgcmVzcG9uc2UgY29udGVudC10eXBlIGlzIGpzb24sIGZvcmNlIHRoZSByZXNwb25zZSB0byBiZSBqc29uXG4gICAgICAgIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgICByZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGxldCBibG9iO1xuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgICAgICAgICAgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVhZEJsb2JBc0Jhc2U2NChibG9iKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IGZldGNoIGhlYWRlcnMgdG8gQ2FwYWNpdG9yIEh0dHBIZWFkZXJzXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW4gSHR0cCBHRVQgcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBidWlsZCB0aGUgSFRUUCByZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgZ2V0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1ldGhvZDogJ0dFVCcgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIEh0dHAgUE9TVCByZXF1ZXN0IGdpdmVuIGEgc2V0IG9mIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAgICAgKi9cbiAgICBhc3luYyBwb3N0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1ldGhvZDogJ1BPU1QnIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbiBIdHRwIFBVVCByZXF1ZXN0IGdpdmVuIGEgc2V0IG9mIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAgICAgKi9cbiAgICBhc3luYyBwdXQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgbWV0aG9kOiAnUFVUJyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW4gSHR0cCBQQVRDSCByZXF1ZXN0IGdpdmVuIGEgc2V0IG9mIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAgICAgKi9cbiAgICBhc3luYyBwYXRjaChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtZXRob2Q6ICdQQVRDSCcgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIEh0dHAgREVMRVRFIHJlcXVlc3QgZ2l2ZW4gYSBzZXQgb2Ygb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gYnVpbGQgdGhlIEhUVFAgcmVxdWVzdFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtZXRob2Q6ICdERUxFVEUnIH0pKTtcbiAgICB9XG59XG5jb25zdCBDYXBhY2l0b3JIdHRwID0gcmVnaXN0ZXJQbHVnaW4oJ0NhcGFjaXRvckh0dHAnLCB7XG4gICAgd2ViOiAoKSA9PiBuZXcgQ2FwYWNpdG9ySHR0cFBsdWdpbldlYigpLFxufSk7XG4vKioqKioqKiogRU5EIEhUVFAgUExVR0lOICoqKioqKioqL1xuLyoqKioqKioqIFNZU1RFTSBCQVJTIFBMVUdJTiAqKioqKioqKi9cbi8qKlxuICogQXZhaWxhYmxlIHN0YXR1cyBiYXIgc3R5bGVzLlxuICovXG52YXIgU3lzdGVtQmFyc1N0eWxlO1xuKGZ1bmN0aW9uIChTeXN0ZW1CYXJzU3R5bGUpIHtcbiAgICAvKipcbiAgICAgKiBMaWdodCBzeXN0ZW0gYmFyIGNvbnRlbnQgb24gYSBkYXJrIGJhY2tncm91bmQuXG4gICAgICpcbiAgICAgKiBAc2luY2UgOC4wLjBcbiAgICAgKi9cbiAgICBTeXN0ZW1CYXJzU3R5bGVbXCJEYXJrXCJdID0gXCJEQVJLXCI7XG4gICAgLyoqXG4gICAgICogRm9yIGRhcmsgc3lzdGVtIGJhciBjb250ZW50IG9uIGEgbGlnaHQgYmFja2dyb3VuZC5cbiAgICAgKlxuICAgICAqIEBzaW5jZSA4LjAuMFxuICAgICAqL1xuICAgIFN5c3RlbUJhcnNTdHlsZVtcIkxpZ2h0XCJdID0gXCJMSUdIVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzdHlsZSBpcyBiYXNlZCBvbiB0aGUgZGV2aWNlIGFwcGVhcmFuY2Ugb3IgdGhlIHVuZGVybHlpbmcgY29udGVudC5cbiAgICAgKiBJZiB0aGUgZGV2aWNlIGlzIHVzaW5nIERhcmsgbW9kZSwgdGhlIHN5c3RlbSBiYXJzIGNvbnRlbnQgd2lsbCBiZSBsaWdodC5cbiAgICAgKiBJZiB0aGUgZGV2aWNlIGlzIHVzaW5nIExpZ2h0IG1vZGUsIHRoZSBzeXN0ZW0gYmFycyBjb250ZW50IHdpbGwgYmUgZGFyay5cbiAgICAgKlxuICAgICAqIEBzaW5jZSA4LjAuMFxuICAgICAqL1xuICAgIFN5c3RlbUJhcnNTdHlsZVtcIkRlZmF1bHRcIl0gPSBcIkRFRkFVTFRcIjtcbn0pKFN5c3RlbUJhcnNTdHlsZSB8fCAoU3lzdGVtQmFyc1N0eWxlID0ge30pKTtcbi8qKlxuICogQXZhaWxhYmxlIHN5c3RlbSBiYXIgdHlwZXMuXG4gKi9cbnZhciBTeXN0ZW1CYXJUeXBlO1xuKGZ1bmN0aW9uIChTeXN0ZW1CYXJUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRvcCBzdGF0dXMgYmFyIG9uIGJvdGggQW5kcm9pZCBhbmQgaU9TLlxuICAgICAqXG4gICAgICogQHNpbmNlIDguMC4wXG4gICAgICovXG4gICAgU3lzdGVtQmFyVHlwZVtcIlN0YXR1c0JhclwiXSA9IFwiU3RhdHVzQmFyXCI7XG4gICAgLyoqXG4gICAgICogVGhlIG5hdmlnYXRpb24gYmFyIChvciBnZXN0dXJlIGJhciBvbiBpT1MpIG9uIGJvdGggQW5kcm9pZCBhbmQgaU9TLlxuICAgICAqXG4gICAgICogQHNpbmNlIDguMC4wXG4gICAgICovXG4gICAgU3lzdGVtQmFyVHlwZVtcIk5hdmlnYXRpb25CYXJcIl0gPSBcIk5hdmlnYXRpb25CYXJcIjtcbn0pKFN5c3RlbUJhclR5cGUgfHwgKFN5c3RlbUJhclR5cGUgPSB7fSkpO1xuY2xhc3MgU3lzdGVtQmFyc1BsdWdpbldlYiBleHRlbmRzIFdlYlBsdWdpbiB7XG4gICAgYXN5bmMgc2V0U3R5bGUoKSB7XG4gICAgICAgIHRoaXMudW5hdmFpbGFibGUoJ25vdCBhdmFpbGFibGUgZm9yIHdlYicpO1xuICAgIH1cbiAgICBhc3luYyBzZXRBbmltYXRpb24oKSB7XG4gICAgICAgIHRoaXMudW5hdmFpbGFibGUoJ25vdCBhdmFpbGFibGUgZm9yIHdlYicpO1xuICAgIH1cbiAgICBhc3luYyBzaG93KCkge1xuICAgICAgICB0aGlzLnVuYXZhaWxhYmxlKCdub3QgYXZhaWxhYmxlIGZvciB3ZWInKTtcbiAgICB9XG4gICAgYXN5bmMgaGlkZSgpIHtcbiAgICAgICAgdGhpcy51bmF2YWlsYWJsZSgnbm90IGF2YWlsYWJsZSBmb3Igd2ViJyk7XG4gICAgfVxufVxuY29uc3QgU3lzdGVtQmFycyA9IHJlZ2lzdGVyUGx1Z2luKCdTeXN0ZW1CYXJzJywge1xuICAgIHdlYjogKCkgPT4gbmV3IFN5c3RlbUJhcnNQbHVnaW5XZWIoKSxcbn0pO1xuLyoqKioqKioqIEVORCBTWVNURU0gQkFSUyBQTFVHSU4gKioqKioqKiovXG5cbmV4cG9ydCB7IENhcGFjaXRvciwgQ2FwYWNpdG9yQ29va2llcywgQ2FwYWNpdG9yRXhjZXB0aW9uLCBDYXBhY2l0b3JIdHRwLCBFeGNlcHRpb25Db2RlLCBTeXN0ZW1CYXJUeXBlLCBTeXN0ZW1CYXJzLCBTeXN0ZW1CYXJzU3R5bGUsIFdlYlBsdWdpbiwgV2ViVmlldywgYnVpbGRSZXF1ZXN0SW5pdCwgcmVnaXN0ZXJQbHVnaW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@capacitor/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@capacitor/device/dist/esm/definitions.js":
/*!****************************************************************!*\
  !*** ./node_modules/@capacitor/device/dist/esm/definitions.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=definitions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci9kZXZpY2UvZGlzdC9lc20vZGVmaW5pdGlvbnMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIi9ob21lL3VzZXIvc3R1ZGlvL25vZGVfbW9kdWxlcy9AY2FwYWNpdG9yL2RldmljZS9kaXN0L2VzbS9kZWZpbml0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZpbml0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@capacitor/device/dist/esm/definitions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@capacitor/device/dist/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@capacitor/device/dist/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Device: () => (/* binding */ Device)\n/* harmony export */ });\n/* harmony import */ var _capacitor_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @capacitor/core */ \"(ssr)/./node_modules/@capacitor/core/dist/index.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definitions */ \"(ssr)/./node_modules/@capacitor/device/dist/esm/definitions.js\");\n\nconst Device = (0,_capacitor_core__WEBPACK_IMPORTED_MODULE_0__.registerPlugin)('Device', {\n    web: () => __webpack_require__.e(/*! import() */ \"vendor-chunks/@capacitor\").then(__webpack_require__.bind(__webpack_require__, /*! ./web */ \"(ssr)/./node_modules/@capacitor/device/dist/esm/web.js\")).then((m) => new m.DeviceWeb()),\n});\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci9kZXZpY2UvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlEO0FBQ2pELGVBQWUsK0RBQWM7QUFDN0IsZUFBZSw0TEFBZTtBQUM5QixDQUFDO0FBQzZCO0FBQ1o7QUFDbEIiLCJzb3VyY2VzIjpbIi9ob21lL3VzZXIvc3R1ZGlvL25vZGVfbW9kdWxlcy9AY2FwYWNpdG9yL2RldmljZS9kaXN0L2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWdpc3RlclBsdWdpbiB9IGZyb20gJ0BjYXBhY2l0b3IvY29yZSc7XG5jb25zdCBEZXZpY2UgPSByZWdpc3RlclBsdWdpbignRGV2aWNlJywge1xuICAgIHdlYjogKCkgPT4gaW1wb3J0KCcuL3dlYicpLnRoZW4oKG0pID0+IG5ldyBtLkRldmljZVdlYigpKSxcbn0pO1xuZXhwb3J0ICogZnJvbSAnLi9kZWZpbml0aW9ucyc7XG5leHBvcnQgeyBEZXZpY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@capacitor/device/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@capacitor/device/dist/esm/web.js":
/*!********************************************************!*\
  !*** ./node_modules/@capacitor/device/dist/esm/web.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DeviceWeb: () => (/* binding */ DeviceWeb)\n/* harmony export */ });\n/* harmony import */ var _capacitor_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @capacitor/core */ \"(ssr)/./node_modules/@capacitor/core/dist/index.js\");\n\nclass DeviceWeb extends _capacitor_core__WEBPACK_IMPORTED_MODULE_0__.WebPlugin {\n    async getId() {\n        return {\n            identifier: this.getUid(),\n        };\n    }\n    async getInfo() {\n        if (typeof navigator === 'undefined' || !navigator.userAgent) {\n            throw this.unavailable('Device API not available in this browser');\n        }\n        const ua = navigator.userAgent;\n        const uaFields = this.parseUa(ua);\n        return {\n            model: uaFields.model,\n            platform: 'web',\n            operatingSystem: uaFields.operatingSystem,\n            osVersion: uaFields.osVersion,\n            manufacturer: navigator.vendor,\n            isVirtual: false,\n            webViewVersion: uaFields.browserVersion,\n        };\n    }\n    async getBatteryInfo() {\n        if (typeof navigator === 'undefined' || !navigator.getBattery) {\n            throw this.unavailable('Device API not available in this browser');\n        }\n        let battery = {};\n        try {\n            battery = await navigator.getBattery();\n        }\n        catch (e) {\n            // Let it fail, we don't care\n        }\n        return {\n            batteryLevel: battery.level,\n            isCharging: battery.charging,\n        };\n    }\n    async getLanguageCode() {\n        return {\n            value: navigator.language.split('-')[0].toLowerCase(),\n        };\n    }\n    async getLanguageTag() {\n        return {\n            value: navigator.language,\n        };\n    }\n    parseUa(ua) {\n        const uaFields = {};\n        const start = ua.indexOf('(') + 1;\n        let end = ua.indexOf(') AppleWebKit');\n        if (ua.indexOf(') Gecko') !== -1) {\n            end = ua.indexOf(') Gecko');\n        }\n        const fields = ua.substring(start, end);\n        if (ua.indexOf('Android') !== -1) {\n            const tmpFields = fields.replace('; wv', '').split('; ').pop();\n            if (tmpFields) {\n                uaFields.model = tmpFields.split(' Build')[0];\n            }\n            uaFields.osVersion = fields.split('; ')[1];\n        }\n        else {\n            uaFields.model = fields.split('; ')[0];\n            if (typeof navigator !== 'undefined' && navigator.oscpu) {\n                uaFields.osVersion = navigator.oscpu;\n            }\n            else {\n                if (ua.indexOf('Windows') !== -1) {\n                    uaFields.osVersion = fields;\n                }\n                else {\n                    const tmpFields = fields.split('; ').pop();\n                    if (tmpFields) {\n                        const lastParts = tmpFields.replace(' like Mac OS X', '').split(' ');\n                        uaFields.osVersion = lastParts[lastParts.length - 1].replace(/_/g, '.');\n                    }\n                }\n            }\n        }\n        if (/android/i.test(ua)) {\n            uaFields.operatingSystem = 'android';\n        }\n        else if (/iPad|iPhone|iPod/.test(ua) && !window.MSStream) {\n            uaFields.operatingSystem = 'ios';\n        }\n        else if (/Win/.test(ua)) {\n            uaFields.operatingSystem = 'windows';\n        }\n        else if (/Mac/i.test(ua)) {\n            uaFields.operatingSystem = 'mac';\n        }\n        else {\n            uaFields.operatingSystem = 'unknown';\n        }\n        // Check for browsers based on non-standard javascript apis, only not user agent\n        const isSafari = !!window.ApplePaySession;\n        const isChrome = !!window.chrome;\n        const isFirefox = /Firefox/.test(ua);\n        const isEdge = /Edg/.test(ua);\n        const isFirefoxIOS = /FxiOS/.test(ua);\n        const isChromeIOS = /CriOS/.test(ua);\n        const isEdgeIOS = /EdgiOS/.test(ua);\n        // FF and Edge User Agents both end with \"/MAJOR.MINOR\"\n        if (isSafari || (isChrome && !isEdge) || isFirefoxIOS || isChromeIOS || isEdgeIOS) {\n            // Safari version comes as     \"... Version/MAJOR.MINOR ...\"\n            // Chrome version comes as     \"... Chrome/MAJOR.MINOR ...\"\n            // FirefoxIOS version comes as \"... FxiOS/MAJOR.MINOR ...\"\n            // ChromeIOS version comes as  \"... CriOS/MAJOR.MINOR ...\"\n            let searchWord;\n            if (isFirefoxIOS) {\n                searchWord = 'FxiOS';\n            }\n            else if (isChromeIOS) {\n                searchWord = 'CriOS';\n            }\n            else if (isEdgeIOS) {\n                searchWord = 'EdgiOS';\n            }\n            else if (isSafari) {\n                searchWord = 'Version';\n            }\n            else {\n                searchWord = 'Chrome';\n            }\n            const words = ua.split(' ');\n            for (const word of words) {\n                if (word.includes(searchWord)) {\n                    const version = word.split('/')[1];\n                    uaFields.browserVersion = version;\n                }\n            }\n        }\n        else if (isFirefox || isEdge) {\n            const reverseUA = ua.split('').reverse().join('');\n            const reverseVersion = reverseUA.split('/')[0];\n            const version = reverseVersion.split('').reverse().join('');\n            uaFields.browserVersion = version;\n        }\n        return uaFields;\n    }\n    getUid() {\n        if (typeof window !== 'undefined' && window.localStorage) {\n            let uid = window.localStorage.getItem('_capuid');\n            if (uid) {\n                return uid;\n            }\n            uid = this.uuid4();\n            window.localStorage.setItem('_capuid', uid);\n            return uid;\n        }\n        return this.uuid4();\n    }\n    uuid4() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }\n}\n//# sourceMappingURL=web.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci9kZXZpY2UvZGlzdC9lc20vd2ViLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQ3JDLHdCQUF3QixzREFBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3VzZXIvc3R1ZGlvL25vZGVfbW9kdWxlcy9AY2FwYWNpdG9yL2RldmljZS9kaXN0L2VzbS93ZWIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV2ViUGx1Z2luIH0gZnJvbSAnQGNhcGFjaXRvci9jb3JlJztcbmV4cG9ydCBjbGFzcyBEZXZpY2VXZWIgZXh0ZW5kcyBXZWJQbHVnaW4ge1xuICAgIGFzeW5jIGdldElkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogdGhpcy5nZXRVaWQoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SW5mbygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnVuYXZhaWxhYmxlKCdEZXZpY2UgQVBJIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICBjb25zdCB1YUZpZWxkcyA9IHRoaXMucGFyc2VVYSh1YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlbDogdWFGaWVsZHMubW9kZWwsXG4gICAgICAgICAgICBwbGF0Zm9ybTogJ3dlYicsXG4gICAgICAgICAgICBvcGVyYXRpbmdTeXN0ZW06IHVhRmllbGRzLm9wZXJhdGluZ1N5c3RlbSxcbiAgICAgICAgICAgIG9zVmVyc2lvbjogdWFGaWVsZHMub3NWZXJzaW9uLFxuICAgICAgICAgICAgbWFudWZhY3R1cmVyOiBuYXZpZ2F0b3IudmVuZG9yLFxuICAgICAgICAgICAgaXNWaXJ0dWFsOiBmYWxzZSxcbiAgICAgICAgICAgIHdlYlZpZXdWZXJzaW9uOiB1YUZpZWxkcy5icm93c2VyVmVyc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmF0dGVyeUluZm8oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmdldEJhdHRlcnkpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMudW5hdmFpbGFibGUoJ0RldmljZSBBUEkgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmF0dGVyeSA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmF0dGVyeSA9IGF3YWl0IG5hdmlnYXRvci5nZXRCYXR0ZXJ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIExldCBpdCBmYWlsLCB3ZSBkb24ndCBjYXJlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhdHRlcnlMZXZlbDogYmF0dGVyeS5sZXZlbCxcbiAgICAgICAgICAgIGlzQ2hhcmdpbmc6IGJhdHRlcnkuY2hhcmdpbmcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldExhbmd1YWdlQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBuYXZpZ2F0b3IubGFuZ3VhZ2Uuc3BsaXQoJy0nKVswXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRMYW5ndWFnZVRhZygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBuYXZpZ2F0b3IubGFuZ3VhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhcnNlVWEodWEpIHtcbiAgICAgICAgY29uc3QgdWFGaWVsZHMgPSB7fTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB1YS5pbmRleE9mKCcoJykgKyAxO1xuICAgICAgICBsZXQgZW5kID0gdWEuaW5kZXhPZignKSBBcHBsZVdlYktpdCcpO1xuICAgICAgICBpZiAodWEuaW5kZXhPZignKSBHZWNrbycpICE9PSAtMSkge1xuICAgICAgICAgICAgZW5kID0gdWEuaW5kZXhPZignKSBHZWNrbycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHVhLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKHVhLmluZGV4T2YoJ0FuZHJvaWQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcEZpZWxkcyA9IGZpZWxkcy5yZXBsYWNlKCc7IHd2JywgJycpLnNwbGl0KCc7ICcpLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHRtcEZpZWxkcykge1xuICAgICAgICAgICAgICAgIHVhRmllbGRzLm1vZGVsID0gdG1wRmllbGRzLnNwbGl0KCcgQnVpbGQnKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVhRmllbGRzLm9zVmVyc2lvbiA9IGZpZWxkcy5zcGxpdCgnOyAnKVsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVhRmllbGRzLm1vZGVsID0gZmllbGRzLnNwbGl0KCc7ICcpWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5vc2NwdSkge1xuICAgICAgICAgICAgICAgIHVhRmllbGRzLm9zVmVyc2lvbiA9IG5hdmlnYXRvci5vc2NwdTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh1YS5pbmRleE9mKCdXaW5kb3dzJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHVhRmllbGRzLm9zVmVyc2lvbiA9IGZpZWxkcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcEZpZWxkcyA9IGZpZWxkcy5zcGxpdCgnOyAnKS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFBhcnRzID0gdG1wRmllbGRzLnJlcGxhY2UoJyBsaWtlIE1hYyBPUyBYJywgJycpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1YUZpZWxkcy5vc1ZlcnNpb24gPSBsYXN0UGFydHNbbGFzdFBhcnRzLmxlbmd0aCAtIDFdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoL2FuZHJvaWQvaS50ZXN0KHVhKSkge1xuICAgICAgICAgICAgdWFGaWVsZHMub3BlcmF0aW5nU3lzdGVtID0gJ2FuZHJvaWQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KHVhKSAmJiAhd2luZG93Lk1TU3RyZWFtKSB7XG4gICAgICAgICAgICB1YUZpZWxkcy5vcGVyYXRpbmdTeXN0ZW0gPSAnaW9zJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvV2luLy50ZXN0KHVhKSkge1xuICAgICAgICAgICAgdWFGaWVsZHMub3BlcmF0aW5nU3lzdGVtID0gJ3dpbmRvd3MnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9NYWMvaS50ZXN0KHVhKSkge1xuICAgICAgICAgICAgdWFGaWVsZHMub3BlcmF0aW5nU3lzdGVtID0gJ21hYyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1YUZpZWxkcy5vcGVyYXRpbmdTeXN0ZW0gPSAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGJyb3dzZXJzIGJhc2VkIG9uIG5vbi1zdGFuZGFyZCBqYXZhc2NyaXB0IGFwaXMsIG9ubHkgbm90IHVzZXIgYWdlbnRcbiAgICAgICAgY29uc3QgaXNTYWZhcmkgPSAhIXdpbmRvdy5BcHBsZVBheVNlc3Npb247XG4gICAgICAgIGNvbnN0IGlzQ2hyb21lID0gISF3aW5kb3cuY2hyb21lO1xuICAgICAgICBjb25zdCBpc0ZpcmVmb3ggPSAvRmlyZWZveC8udGVzdCh1YSk7XG4gICAgICAgIGNvbnN0IGlzRWRnZSA9IC9FZGcvLnRlc3QodWEpO1xuICAgICAgICBjb25zdCBpc0ZpcmVmb3hJT1MgPSAvRnhpT1MvLnRlc3QodWEpO1xuICAgICAgICBjb25zdCBpc0Nocm9tZUlPUyA9IC9DcmlPUy8udGVzdCh1YSk7XG4gICAgICAgIGNvbnN0IGlzRWRnZUlPUyA9IC9FZGdpT1MvLnRlc3QodWEpO1xuICAgICAgICAvLyBGRiBhbmQgRWRnZSBVc2VyIEFnZW50cyBib3RoIGVuZCB3aXRoIFwiL01BSk9SLk1JTk9SXCJcbiAgICAgICAgaWYgKGlzU2FmYXJpIHx8IChpc0Nocm9tZSAmJiAhaXNFZGdlKSB8fCBpc0ZpcmVmb3hJT1MgfHwgaXNDaHJvbWVJT1MgfHwgaXNFZGdlSU9TKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgdmVyc2lvbiBjb21lcyBhcyAgICAgXCIuLi4gVmVyc2lvbi9NQUpPUi5NSU5PUiAuLi5cIlxuICAgICAgICAgICAgLy8gQ2hyb21lIHZlcnNpb24gY29tZXMgYXMgICAgIFwiLi4uIENocm9tZS9NQUpPUi5NSU5PUiAuLi5cIlxuICAgICAgICAgICAgLy8gRmlyZWZveElPUyB2ZXJzaW9uIGNvbWVzIGFzIFwiLi4uIEZ4aU9TL01BSk9SLk1JTk9SIC4uLlwiXG4gICAgICAgICAgICAvLyBDaHJvbWVJT1MgdmVyc2lvbiBjb21lcyBhcyAgXCIuLi4gQ3JpT1MvTUFKT1IuTUlOT1IgLi4uXCJcbiAgICAgICAgICAgIGxldCBzZWFyY2hXb3JkO1xuICAgICAgICAgICAgaWYgKGlzRmlyZWZveElPUykge1xuICAgICAgICAgICAgICAgIHNlYXJjaFdvcmQgPSAnRnhpT1MnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDaHJvbWVJT1MpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hXb3JkID0gJ0NyaU9TJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRWRnZUlPUykge1xuICAgICAgICAgICAgICAgIHNlYXJjaFdvcmQgPSAnRWRnaU9TJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoV29yZCA9ICdWZXJzaW9uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlYXJjaFdvcmQgPSAnQ2hyb21lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gdWEuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd29yZCBvZiB3b3Jkcykge1xuICAgICAgICAgICAgICAgIGlmICh3b3JkLmluY2x1ZGVzKHNlYXJjaFdvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB3b3JkLnNwbGl0KCcvJylbMV07XG4gICAgICAgICAgICAgICAgICAgIHVhRmllbGRzLmJyb3dzZXJWZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNGaXJlZm94IHx8IGlzRWRnZSkge1xuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZVVBID0gdWEuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbiAgICAgICAgICAgIGNvbnN0IHJldmVyc2VWZXJzaW9uID0gcmV2ZXJzZVVBLnNwbGl0KCcvJylbMF07XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gcmV2ZXJzZVZlcnNpb24uc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbiAgICAgICAgICAgIHVhRmllbGRzLmJyb3dzZXJWZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdWFGaWVsZHM7XG4gICAgfVxuICAgIGdldFVpZCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGxldCB1aWQgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ19jYXB1aWQnKTtcbiAgICAgICAgICAgIGlmICh1aWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdWlkID0gdGhpcy51dWlkNCgpO1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdfY2FwdWlkJywgdWlkKTtcbiAgICAgICAgICAgIHJldHVybiB1aWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudXVpZDQoKTtcbiAgICB9XG4gICAgdXVpZDQoKSB7XG4gICAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@capacitor/device/dist/esm/web.js\n");

/***/ })

};
;